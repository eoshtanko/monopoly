/**
 * @author <a href="mailto:eoshtanko@edu.hse.ru"> Ekaterina Shtanko</a>
 */
package tools;

import java.util.Random;

/**
 * Класс, содержащий методы генерации значений.
 * Я приняла решение выделить генерацию в отдельный класс, так как:
 * 1) Это позволит избежать повторение кода, сделать код чище.
 * 2) Это решение показалось мне корректным с точки зрения архитектуры. Данные
 * методы не соотносятся напрямую с логикой специфических, специализированных классов программы.
 * Они - просто интструменты и должны быть отделены.
 */
public class Values {
    public static final Random rnd = new Random();

    /**
     * Генерирует случайное значение типа bool
     *
     * @return случайное значение bool(true/false)
     */
    public static boolean genBool() {
        return rnd.nextInt(2) == 0;
    }

    /**
     * Генерирует случайное вещественное число в диапозоне [a, b)
     *
     * @param a начальня граница(включительно)
     * @param b конечная граница(невключительно)
     * @return случайное вещественное число в диапозоне [a, b)
     */
    public static double genDouble(double a, double b) {
        return rnd.nextDouble() * (b - a) + a;
    }

    /**
     * Генерирует случайное целое число в диапозоне [a, b]
     *
     * @param a начальня граница(включительно)
     * @param b конечная граница(включительно)
     * @return случайное целое число в диапозоне [a, b]
     */
    public static int genInt(int a, int b) {
        return rnd.nextInt(b - a + 1) + a;
    }

    /**
     * Округляет число до трех знаков после запятой.
     * Этот метод необходим, чтобы выводимая информация соответствовала истине.
     * Так как я округляяю при выводе некоторые коэффициенты, то и расчеты должны
     * соответствовать округленному значению.
     * Этот метод позволит округлять коэффиценты еще до расчета.
     * @return вещественное число, округленное до трех знаков после запятой
     */
    public static double round(double numBefore) {
        //Данный метод нужен, чтобы выводимая информация соответствовала истине
        //Ситуация:
        //(здесь пример округления до 2 знаков, но если даже мы будем округлять
        // до трех, такая ситуация все же возникает)
        //Генерирую penaltyCoeff. Он равен 0,03769...
        //В начале игры я его вывела как 0,04(к примеру)
        //
        //Время расчетов:
        //В методе: penaltyCoeff*money:
        // 0,03769*500=18,5
        //округляю -> 19
        //Но 0,04*500=20.
        //
        // Округляя коэффициент еще до умножения, можно избежать
        // подобной ошибки.
        String stringNum = String.format("%.3f", numBefore).replace(',', '.');
        return Double.parseDouble(stringNum);
    }
}